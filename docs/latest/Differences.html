<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>Differences</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="Differences.css" /> 
<meta name="src" content="Differences.tex" /> 
<link rel="stylesheet" type="text/css" href="../main.css" /></head><body 
><div class="center" 
>
<!--l. 142--><p class="noindent" >
</p><!--l. 149--><p class="noindent" > <img 
src="Logos/Logo.png" alt="PIC"  
width="160" height="160"  />
</p><!--l. 153--><p class="noindent" >OpenCore
</p><!--l. 157--><p class="noindent" >Reference Manual (0.7<span class="sout">.7</span><span class="uwave">.8</span>)
</p><!--l. 161--><p class="noindent" >[2022.02.06]
</p><!--l. 169--><p class="noindent" >Copyright ©2018-2022 vit9696
</p>
</div>
                                                                                                  
                                                                                                  
         </li>
         <li class="itemize">
         <!--l. 3298--><p class="noindent" >System — create no boot option but assume specified custom option is blessed. </p>
             <ul class="itemize2">
             <li class="itemize">
             <!--l. 3301--><p class="noindent" >This variant is useful when relying on ForceBooterSignature quirk and OpenCore launcher path
             management happens through bless utilities without involving OpenCore.</p></li></ul>
         </li></ul>
     <!--l. 3307--><p class="noindent" >This option allows integration with third-party operating system installation and upgrades (which may overwrite the
     \EFI\BOOT\BOOTx64.efi file). The BOOTx64.efi file is no longer used for bootstrapping OpenCore if a custom
     option is created. The custom path used for bootstrapping can be specified by using the LauncherPath
     option.
     </p><!--l. 3312--><p class="noindent" >Note 1: Some types of firmware may have NVRAM implementation flaws, no boot option support, or other
     incompatibilities. While unlikely, the use of this option may result in boot failures and should only be used exclusively on
     boards known to be compatible. Refer to <a 
href="https://github.com/acidanthera/bugtracker/issues/1222" >acidanthera/bugtracker#1222</a> for some known issues affecting Haswell and
     other boards.
     </p><!--l. 3318--><p class="noindent" >Note 2: While NVRAM resets executed from OpenCore would not typically erase the boot option created in Bootstrap,
     executing NVRAM resets prior to loading OpenCore will erase the boot option. Therefore, for significant implementation
     updates, such as was the case with OpenCore 0.6.4, an NVRAM reset should be executed with Bootstrap disabled, after
     which it can be re-enabled.
     </p><!--l. 3323--><p class="noindent" ><span class="uwave">Note 3</span><span class="uwave">: Some versions of Intel Visual BIOS (e.g. on Intel NUC) have an unfortunate bug whereby if any boot option is
     added referring to a path on a USB drive, from then on that is the only boot option which will be shown when any USB
     drive is inserted. If OpenCore is started from a USB drive on this firmware with </span><span class="uwave">LauncherOption</span> <span class="uwave">set to </span><span class="uwave">Full</span> <span class="uwave">or
     </span><span class="uwave">Short</span><span class="uwave">, this applies and only the OpenCore boot entry will be seen afterwards, when any other USB is
     inserted (this highly non-standard BIOS behaviour affects other software as well). The best way to avoid
     this is to leave </span><span class="uwave">LauncherOption</span> <span class="uwave">set to </span><span class="uwave">Disabled</span> <span class="uwave">or </span><span class="uwave">System</span> <span class="uwave">on any version of OpenCore which will be
     started from a USB drive on this firmware. If the problem has already occurred the quickest reliable fix is:
     </span></p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 3333--><p class="noindent" ><span class="uwave">Enable the system UEFI Shell in Intel Visual BIOS </span>
         </p></li>
         <li class="itemize">
         <!--l. 3334--><p class="noindent" ><span class="uwave">With power off, insert an OpenCore USB </span>
         </p></li>
         <li class="itemize">
         <!--l. 3335--><p class="noindent" ><span class="uwave">Power up and select the system UEFI Shell </span>
         </p></li>
         <li class="itemize">
         <!--l. 3336--><p class="noindent" ><span class="uwave">Since the system shell does not include </span><span class="uwave">bcfg</span><span class="uwave">, use the system shell to start OpenCore’s OpenShell (e.g. by
         entering the command </span><span class="uwave">FS2:\EFI\OC\Tools\OpenShell.efi</span> <span class="uwave">, but you will need to work out which drive is
         correct for OpenCore and modify the drive number </span><span class="uwave">FS#:</span> <span class="uwave">accordingly) </span>
         </p></li>
         <li class="itemize">
         <!--l. 3339--><p class="noindent" ><span class="uwave">Within OpenShell, use </span><span class="uwave">bcfg boot dump</span> <span class="uwave">to display the NVRAM boot options and then use </span><span class="uwave">bcfg boot rm
         #</span> <span class="uwave">(where </span><span class="uwave">#</span> <span class="uwave">is the number of the OpenCore boot entry) to remove the OpenCore entry </span></p></li></ul>
     <!--l. 3343--><p class="noindent" ><span class="uwave">It is alternatively possible to start OpenShell directly from the OpenCore boot menu, if you have a working configured
     OpenCore for the system. In that case, and if OpenCore has </span><span class="uwave">RequestBootVarRouting</span> <span class="uwave">enabled, it will be necessary to run
     the command </span><span class="uwave">\EFI\OC\Tools\OpenControl.efi disable</span> <span class="uwave">before using </span><span class="uwave">bcfg</span><span class="uwave">. (After </span><span class="uwave">OpenControl disable</span><span class="uwave">, it is
     necessary to either reboot or run </span><span class="uwave">OpenControl restore</span><span class="uwave">, before booting an operating system.) It is also possible to use
     </span><span class="uwave">efibootmgr</span> <span class="uwave">within Linux to remove the offending entry, if you have a working version of Linux on the machine. Linux
     must be started either not via OpenCore, or via OpenCore with </span><span class="uwave">RequestBootVarRouting</span> <span class="uwave">disabled for this to work.
     </span>
     </p></li>
                                                                                                  
                                                                                                  
<li 
  class="enumerate" id="x1-44010x5">
     <!--l. 3353--><p class="noindent" >LauncherPath<br 
class="newline" />Type: plist string<br 
class="newline" />Failsafe: Default<br 
class="newline" />Description: Launch path for the LauncherOption property.
     </p><!--l. 3358--><p class="noindent" >Default points to OpenCore.efi. User specified paths, e.g. \EFI\SomeLauncher.efi, can be used to provide custom
     loaders, which are supposed to load OpenCore.efi themselves.
     </p></li>
<li 
  class="enumerate" id="x1-44012x6">
     <!--l. 3364--><p class="noindent" >PickerAttributes<br 
class="newline" />Type: plist integer<br 
class="newline" />Failsafe: 0<br 
class="newline" />Description: Sets specific attributes for the OpenCore picker.
     </p><!--l. 3369--><p class="noindent" >Different OpenCore pickers may be configured through the attribute mask containing OpenCore-reserved (BIT0~BIT15)
     and OEM-specific (BIT16~BIT31) values.
     </p><!--l. 3373--><p class="noindent" >Current OpenCore values include:
</p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 3377--><p class="noindent" >0x0001 — OC_ATTR_USE_VOLUME_ICON, provides custom icons for boot entries:
         </p><!--l. 3380--><p class="noindent" >OpenCore will attempt loading a volume icon by searching as follows, and will fallback to the default icon on failure:
         </p>
             <ul class="itemize2">
             <li class="itemize">
             <!--l. 3384--><p class="noindent" >.VolumeIcon.icns       file           at           Preboot       volume           in           per-volume
             directory (/System/Volumes/Preboot/{GUID}/ when mounted at the default location within macOS)
             for APFS (if present).
             </p></li>
             <li class="itemize">
             <!--l. 3387--><p class="noindent" >.VolumeIcon.icns file at the Preboot volume root (/System/Volumes/Preboot/, when mounted at
             the default location within macOS) for APFS (otherwise).
             </p></li>
             <li class="itemize">
             <!--l. 3390--><p class="noindent" >.VolumeIcon.icns file at the volume root for other filesystems.</p></li></ul>
         <!--l. 3393--><p class="noindent" >Note 1: The Apple picker partially supports placing a volume icon file at the operating system’s Data volume root,
         /System/Volumes/Data/, when mounted at the default location within macOS. This approach is flawed: the file is
         neither accessible to OpenCanopy nor to the Apple picker when FileVault 2, which is meant to be the default choice,
         is enabled. Therefore, OpenCanopy does not attempt supporting Apple’s approach. A volume icon file may be
         placed at the root of the Preboot volume for compatibility with both OpenCanopy and the Apple picker, or use the
         Preboot per-volume location as above with OpenCanopy as a preferred alternative to Apple’s approach.
         </p><!--l. 3402--><p class="noindent" >Note 2: Be aware that using a volume icon on any drive overrides the normal OpenCore picker behaviour for
         that drive of selecting the appropriate icon depending on whether the drive is internal or external.
         </p></li>
         <li class="itemize">
         <!--l. 3406--><p class="noindent" >0x0002 — OC_ATTR_USE_DISK_LABEL_FILE, <span class="sout">provides </span><span class="uwave">use </span>custom prerendered titles for boot entries from
         .disk_label (.disk_label_2x) file next to the bootloader for all filesystems. <span class="sout">Prerendered </span><span class="uwave">These </span>labels can be
         generated via the disklabel utility or the bless <span class="uwave">-</span><span class="uwave">-folder {FOLDER_PATH} -</span><span class="uwave">-label {LABEL_TEXT}</span>
         command. When <span class="uwave">prerendered labels are </span>disabled or missing, <span class="uwave">use </span>label text in <span class="sout">(</span>.contentDetails <span class="uwave">(</span>or
         .disk_label.contentDetails) <span class="sout">will be rendered </span><span class="uwave">file next to bootloader </span>if present instead, otherwise the entry name
                                                                                                  
                                                                                                  
         itself will be rendered.
         </p></li>
         <li class="itemize">
         <!--l. 3414--><p class="noindent" >0x0004 — OC_ATTR_USE_GENERIC_LABEL_IMAGE, provides predefined label images for boot entries without custom
         entries. This may however give less detail for the actual boot entry.
         </p></li>
         <li class="itemize">
         <!--l. 3417--><p class="noindent" >0x0008 — OC_ATTR_HIDE_THEMED_ICONS, prefers builtin icons for certain icon categories to match
         the theme style. For example, this could force displaying the builtin Time Machine icon. Requires
         OC_ATTR_USE_VOLUME_ICON.
         </p></li>
         <li class="itemize">
         <!--l. 3420--><p class="noindent" >0x0010 — OC_ATTR_USE_POINTER_CONTROL, enables pointer control in the OpenCore picker when available. For
         example, this could make use of mouse or trackpad to control UI elements.
         </p></li>
         <li class="itemize">
         <!--l. 3423--><p class="noindent" >0x0020 — OC_ATTR_SHOW_DEBUG_DISPLAY, enable display of additional timing and debug information, in Builtin
         picker in DEBUG and NOOPT builds only.
         </p></li>
         <li class="itemize">
         <!--l. 3426--><p class="noindent" >0x0040 — OC_ATTR_USE_MINIMAL_UI, use minimal UI display, no Shutdown or Restart buttons, affects OpenCanopy
         and builtin picker.
         </p></li>
         <li class="itemize">
         <!--l. 3428--><p class="noindent" >0x0080 — OC_ATTR_USE_FLAVOUR_ICON, provides flexible boot entry content description, suitable for picking the
         best media across different content sets:
         </p><!--l. 3432--><p class="noindent" >When enabled, the entry icon in OpenCanopy and the audio assist entry sound in OpenCanopy and builtin boot
         picker are chosen by something called content flavour. To determine content flavour the following algorithm is
         used:
</p>
             <ul class="itemize2">
             <li class="itemize">
             <!--l. 3438--><p class="noindent" >For a Tool the value is read from Flavour field.
             </p></li>
             <li class="itemize">
             <!--l. 3439--><p class="noindent" >For an automatically discovered entry<span class="uwave">, including for boot entry protocol entries such as those generated
             by the OpenLinuxBoot driver, </span>it is read from the .contentFlavour file next to the bootloader, if
             present.
             </p></li>
             <li class="itemize">
             <!--l. 3442--><p class="noindent" >For a custom entry <span class="uwave">specified in the </span><span class="uwave">Entries</span> <span class="uwave">section </span>it is read from the .contentFlavour file next to
             the bootloader if Flavour is Auto, otherwise <span class="uwave">it is </span>specified via the Flavour value itself.
             </p></li>
             <li class="itemize">
             <!--l. 3445--><p class="noindent" >If read flavour is Auto or there is no .contentFlavour, entry flavour is chosen based on the entry type
             (e.g. Windows automatically gets Windows flavour).</p></li></ul>
         <!--l. 3450--><p class="noindent" >The Flavour value is a sequence of : separated names limited to 64 characters of printable 7-bit ASCII. This is
         designed to support up to approximately five names. Each name refers to a flavour, with the first name having the
         highest priority and the last name having the lowest priority. Such a structure allows describing an entry in a more
         specific way, with icons selected flexibly depending on support by the audio-visual pack. A missing audio or icon file
         means the next flavour should be tried, and if all are missing the choice happens based on the type of the
         entry. Example flavour values: BigSur:Apple, Windows10:Windows. OpenShell:UEFIShell:Shell.
         </p><!--l. 3460--><p class="noindent" >Using flavours means that you can switch between icon sets easily, with the flavour selecting the best available icons
         from each set. E.g. specifying icon flavour Debian:Linux will use the icon Debian.icns if provided,
         then will try Linux.icns, then will fall back to the default for an OS, which is HardDrive.icns.
                                                                                                  
                                                                                                  
     
     
     
     
     
      
     
       </body>
</html>