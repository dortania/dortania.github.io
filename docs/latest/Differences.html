<!DOCTYPE html> 
<html lang="en-US" xml:lang="en-US" > 
<head><title>Differences</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="Differences.css" /> 
<meta name="src" content="Differences.tex" /> 
<link rel="stylesheet" type="text/css" href="../main.css" /></head><body 
><div class="center" 
>
<!--l. 142--><p class="noindent" >
</p><!--l. 149--><p class="noindent" > <img 
src="Logos/Logo.png" alt="PIC"  
width="160" height="160"  />
</p><!--l. 153--><p class="noindent" >OpenCore
</p><!--l. 157--><p class="noindent" >Reference Manual (0.7<span class="sout">.5</span><span class="uwave">.6</span>)
</p><!--l. 161--><p class="noindent" >[2021.11.30]
</p><!--l. 169--><p class="noindent" >Copyright ©2018-2021 vit9696
</p>
</div>
                                                                                                  
                                                                                                  
     MacPro5,1 as well as on certain Insyde firmware without garbage collection or with defective garbage
     collection.
     </p></li>
<li 
  class="enumerate" id="x1-26026x13">
     <!--l. 1703--><p class="noindent" >ProtectUefiServices<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Protect UEFI services from being overridden by the firmware.
     </p><!--l. 1708--><p class="noindent" >Some modern firmware, including on virtual machines such as VMware, may update pointers to UEFI services during
     driver loading and related actions. Consequently, this directly obstructs other quirks that affect memory management,
     such as DevirtualiseMmio, ProtectMemoryRegions, or RebuildAppleMemoryMap, and may also obstruct other quirks
     depending on the scope of such.
     </p><!--l. 1716--><p class="noindent" ><span class="uwave">GRUB shim makes similar on-the-fly changes to various UEFI image services, which are also protected against by this
     quirk. </span>
     </p><!--l. 1718--><p class="noindent" >Note <span class="uwave">1</span>: On VMware, the need for this quirk may be determined by the appearance of the “Your Mac OS guest might run
     unreliably with more than one virtual core.” message.
     </p><!--l. 1721--><p class="noindent" ><span class="uwave">Note 2</span><span class="uwave">: This quirk is needed for correct operation if OpenCore is chainloaded from GRUB with BIOS Secure Boot
     enabled. </span>
     </p></li>
<li 
  class="enumerate" id="x1-26028x14">
     <!--l. 1726--><p class="noindent" >ProvideCustomSlide<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Provide custom KASLR slide on low memory.
     </p><!--l. 1731--><p class="noindent" >This option performs memory map analysis of the firmware and checks whether all slides (from 1 to 255) can be used. As
     boot.efi generates this value randomly with rdrand or pseudo randomly rdtsc, there is a chance of boot failure when it
     chooses a conflicting slide. In cases where potential conflicts exist, this option forces macOS to select a pseudo random
     value from the available values. This also ensures that the slide= argument is never passed to the operating system (for
     security reasons).
     </p><!--l. 1739--><p class="noindent" >Note: The need for this quirk is determined by the OCABC: Only N/256 slide values are usable! message in the
     debug log.
     </p></li>
<li 
  class="enumerate" id="x1-26030x15">
     <!--l. 1743--><p class="noindent" >ProvideMaxSlide<br 
class="newline" />Type: plist integer<br 
class="newline" />Failsafe: 0<br 
class="newline" />Description: Provide maximum KASLR slide when higher ones are unavailable.
     </p><!--l. 1748--><p class="noindent" >This option overrides the maximum slide of 255 by a user specified value between 1 and 254 (inclusive) when
     ProvideCustomSlide is enabled. It is assumed that modern firmware allocates pool memory from top
     to bottom, effectively resulting in free memory when slide scanning is used later as temporary memory
     during kernel loading. When such memory is not available, this option stops the evaluation of higher
     slides.
     </p><!--l. 1754--><p class="noindent" >Note: The need for this quirk is determined by random boot failures when ProvideCustomSlide is enabled
     and the randomized slide falls into the unavailable range. When AppleDebug is enabled, the debug log
     typically contains messages such as AAPL: [EB|‘LD:LKC] } Err(0x9). To find the optimal value, append
     slide=X, where X is the slide value, to the boot-args and select the largest one that does not result in boot
     failures.
                                                                                                  
                                                                                                  
     </p></li>
<li 
  class="enumerate" id="x1-26032x16">
     <!--l. 1762--><p class="noindent" >RebuildAppleMemoryMap<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Generate macOS compatible Memory Map.
     </p><!--l. 1767--><p class="noindent" >The Apple kernel has several limitations on parsing the UEFI memory map:
</p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 1771--><p class="noindent" >The Memory map size must not exceed 4096 bytes as the Apple kernel maps it as a single 4K page. As
         some types of firmware can have very large memory maps, potentially over 100 entries, the Apple kernel
         will crash on boot.
         </p></li>
         <li class="itemize">
         <!--l. 1774--><p class="noindent" >The Memory attributes table is ignored. EfiRuntimeServicesCode memory statically gets RX permissions
         while all other memory types get RW permissions. As some firmware drivers may write to global variables at
         runtime, the Apple kernel will crash at calling UEFI runtime services unless the driver .data section has a
         EfiRuntimeServicesData type.</p></li></ul>
     <!--l. 1782--><p class="noindent" >To workaround these limitations, this quirk applies memory attribute table permissions to the memory map passed to the
     Apple kernel and optionally attempts to unify contiguous slots of similar types if the resulting memory map exceeds 4
     KB.
     </p><!--l. 1787--><p class="noindent" >Note 1: Since several types of firmware come with incorrect memory protection tables, this quirk often comes paired with
     SyncRuntimePermissions.
     </p><!--l. 1790--><p class="noindent" >Note 2: The need for this quirk is determined by early boot failures. This quirk replaces EnableWriteUnprotector on
     firmware supporting Memory Attribute Tables (MAT). This quirk is typically unnecessary when using OpenDuetPkg but
     may be required to boot macOS 10.6, and earlier, for reasons that are as yet unclear.
     </p></li>
<li 
  class="enumerate" id="x1-26034x17">
     <!--l. 1797--><p class="noindent" >ResizeAppleGpuBars<br 
class="newline" />Type: plist integer<br 
class="newline" />Failsafe: -1<br 
class="newline" />Description: Reduce GPU PCI BAR sizes for compatibility with macOS.
     </p><!--l. 1802--><p class="noindent" >This quirk reduces GPU PCI BAR sizes for Apple macOS up to the specified value or lower if it is unsupported. The
     specified value follows PCI Resizable BAR spec. <span class="sout">Use </span><span class="sout">0</span> <span class="sout">for 1 MB, </span><span class="sout">1</span> <span class="sout">for 2 MB, </span><span class="sout">2</span> <span class="sout">for 4 MB, and so on up to </span><span class="sout">19</span> <span class="sout">for 512 GB.
     </span><span class="uwave">While </span>Apple macOS supports <span class="uwave">a theoretical </span>1 GB maximum, <span class="sout">which is </span><span class="sout">10</span><span class="sout">.</span><span class="uwave">in practice all non-default values may not work
     correctly. For this reason the only supported value for this quirk is the minimal supported BAR size, i.e. </span><span class="uwave">0</span><span class="uwave">. </span>Use -1 to
     disable this quirk.
     </p><!--l. 1816--><p class="noindent" ><span class="uwave">For development purposes one may take risks and try other values. </span>Consider a GPU with 2 BARs: </p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 1819--><p class="noindent" >BAR0 supports sizes from 256 MB to 8 GB. Its value is 4 GB.
         </p></li>
         <li class="itemize">
         <!--l. 1820--><p class="noindent" >BAR1 supports sizes from 2 MB to 256 MB. Its value is 256 MB.</p></li></ul>
     <!--l. 1823--><p class="noindent" >Example 1: Setting ResizeAppleGpuBars to 1 GB will change BAR0 to 1 GB and leave BAR1 unchanged.
     <br 
class="newline" />Example 2: Setting ResizeAppleGpuBars to 1 MB will change BAR0 to 256 MB and BAR0 to 2 MB. <br 
class="newline" />Example 3: Setting ResizeAppleGpuBars to 16 GB will make no changes.
                                                                                                  
                                                                                                  
     </p><!--l. 1832--><p class="noindent" >Note<span class="sout">1</span>: See ResizeGpuBars quirk for general GPU PCI BAR size configuration and more details about the
     technology.
     </p><!--l. 1835--><p class="noindent" ><span class="sout">Note 2</span><span class="sout">: Certain GPU drivers do not support non-standard BAR sizes, causing sleep wake issues, for this reason for
     macOS it is recommended to use minimal supported BAR sizes, i.e. specify </span><span class="sout">0</span> <span class="sout">(1 MB). </span>
     </p></li>
<li 
  class="enumerate" id="x1-26036x18">
     <!--l. 1844--><p class="noindent" >SetupVirtualMap<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Setup virtual memory at SetVirtualAddresses.
     </p><!--l. 1849--><p class="noindent" >Some types of firmware access memory by virtual addresses after a SetVirtualAddresses call, resulting in early boot
     crashes. This quirk workarounds the problem by performing early boot identity mapping of assigned virtual addresses to
     physical memory.
     </p><!--l. 1854--><p class="noindent" >Note: The need for this quirk is determined by early boot failures.
     </p></li>
<li 
  class="enumerate" id="x1-26038x19">
     <!--l. 1857--><p class="noindent" >SignalAppleOS<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Report macOS being loaded through OS Info for any OS.
     </p><!--l. 1862--><p class="noindent" >This quirk is useful on Mac firmware, which loads different operating systems with different hardware configurations.
     For example, it is supposed to enable Intel GPU in Windows and Linux in some dual-GPU MacBook
     models.
     </p></li>
<li 
  class="enumerate" id="x1-26040x20">
     <!--l. 1867--><p class="noindent" >SyncRuntimePermissions<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Update memory permissions for the runtime environment.
     </p><!--l. 1872--><p class="noindent" >Some types of firmware fail to properly handle runtime permissions: </p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 1875--><p class="noindent" >They incorrectly mark OpenRuntime as not executable in the memory map.
         </p></li>
         <li class="itemize">
         <!--l. 1876--><p class="noindent" >They incorrectly mark OpenRuntime as not executable in the memory attributes table.
         </p></li>
         <li class="itemize">
         <!--l. 1878--><p class="noindent" >They lose entries from the memory attributes table after OpenRuntime is loaded.
         </p></li>
         <li class="itemize">
         <!--l. 1880--><p class="noindent" >They mark items in the memory attributes table as read-write-execute.</p></li></ul>
     <!--l. 1883--><p class="noindent" >This quirk attempts to update the memory map and memory attributes table to correct this.
     </p><!--l. 1885--><p class="noindent" >Note: The need for this quirk is indicated by early boot failures (note: includes halt at black screen as well as more
     obvious crash). Particularly likely to affect early boot of Windows or Linux (but not always both) on affected systems.
     Only firmware released after 2017 is typically affected.
</p>
                                                                                                  
                                                                                                  
<h4 class="subsectionHead"><span class="titlemark">8.5   </span> <a 
 id="x1-460005"></a>Security Properties</h4>
     <ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-46002x1">
     <!--l. 3869--><p class="noindent" >AllowNvramReset<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Allow CMD+OPT+P+R handling and enable showing NVRAM Reset entry in OpenCore picker.
     </p><!--l. 3875--><p class="noindent" >Note 1: It is known that some Lenovo laptops have a firmware bug, which makes them unbootable after performing
     NVRAM reset. Refer to <a 
href="https://github.com/acidanthera/bugtracker/issues/995" >acidanthera/bugtracker#995</a> for details.
     </p><!--l. 3880--><p class="noindent" >Note 2: Resetting NVRAM will also erase any boot options not backed up using the bless command. For example,
     Linux installations to custom locations not specified in BlessOverride
     </p></li>
<li 
  class="enumerate" id="x1-46004x2">
     <!--l. 3885--><p class="noindent" >AllowSetDefault<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Allow CTRL+Enter and CTRL+Index handling to set the default boot option in the OpenCore
     picker.
     </p><!--l. 3891--><p class="noindent" >Note 1: May be used in combination with Shift+Enter or Shift+Index when PollAppleHotKeys is enabled.
     </p><!--l. 3895--><p class="noindent" >Note 2: In order to support systems with unresponsive modifiers during preboot (which includes V1 and V2
     KeySupport mode on some firmware) OpenCore also allows holding the =/+ key in order to trigger ‘set default’
     mode.
     </p></li>
<li 
  class="enumerate" id="x1-46006x3">
     <!--l. 3900--><p class="noindent" >AllowToggleSip<br 
class="newline" />Type: plist boolean<br 
class="newline" />Failsafe: false<br 
class="newline" />Description: Enable entry for disabling and enabling System Integrity Protection in OpenCore picker.
     </p><!--l. 3906--><p class="noindent" >This will toggle Apple NVRAM variable csr-active-config between 0 for SIP Enabled and a practical default
     value for SIP Disabled (currently 0x26F).
     </p><!--l. 3909--><p class="noindent" >Note 1: It is strongly recommended not to make a habit of running macOS with SIP disabled. Use of this boot
     option may make it easier to quickly disable SIP protection when genuinely needed - it should be re-enabled
     again afterwards.
     </p><!--l. 3913--><p class="noindent" >Note 2: <span class="sout">OC </span><span class="uwave">OpenCore </span>uses 0x26F even though csrutil disable on Big Sur sets 0x7F. To explain the choice:
     </p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 3917--><p class="noindent" >csrutil disable --no-internal    actually       sets       0x6F,       and       this       is       preferable
         because CSR_ALLOW_APPLE_INTERNAL (0x10) prevents updates (unless you are running an internal build of
         macOS).
         </p></li>
         <li class="itemize">
         <!--l. 3920--><p class="noindent" >CSR_ALLOW_UNAPPROVED_KEXTS (0x200) is generally useful, in the case where you do need to have SIP
         disabled, as it allows installing unsigned kexts without manual approval in System Preferences.
         </p></li>
         <li class="itemize">
         <!--l. 3923--><p class="noindent" >CSR_ALLOW_UNAUTHENTICATED_ROOT (0x800) is not practical as it prevents incremental (non-full) OTA
                                                                                                  
                                                                                                  
     </p><!--l. 4053--><p class="noindent" >Note: This functionality is still under development and is not ready for production environments.
     </p></li>
<li 
  class="enumerate" id="x1-46025x9">
     <!--l. 4057--><p class="noindent" >ExposeSensitiveData<br 
class="newline" />Type: plist integer<br 
class="newline" />Failsafe: 0x6<br 
class="newline" />Description: Sensitive data exposure bitmask (sum) to operating system.
</p>
         <ul class="itemize1">
         <li class="itemize">
         <!--l. 4064--><p class="noindent" >0x01 — Expose the printable booter path as <span class="sout">an </span><span class="uwave">a </span>UEFI variable.
         </p></li>
         <li class="itemize">
         <!--l. 4065--><p class="noindent" >0x02 — Expose the OpenCore version as <span class="sout">an </span><span class="uwave">a </span>UEFI variable.
         </p></li>
         <li class="itemize">
         <!--l. 4066--><p class="noindent" >0x04 — Expose the OpenCore version in the OpenCore picker menu title.
         </p></li>
         <li class="itemize">
         <!--l. 4067--><p class="noindent" >0x08 — Expose OEM information as a set of UEFI variables.</p></li></ul>
     <!--l. 4070--><p class="noindent" >The exposed booter path points to OpenCore.efi or its booter depending on the load order. To obtain the booter path,
     use the following command in macOS: </p><!--l. 4072-->
<a 
 id="x1-460249"></a>
     <div class="lstlisting" id="listing-10"><span class="label"><a 
 id="x1-46026r1"></a></span>nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:boot-path</div>
     
     <!--l. 4076--><p class="noindent" >To use a booter path to mount a booter volume, use the following command in macOS: </p><!--l. 4077-->
     <div class="lstlisting" id="listing-11"><span class="label"><a 
 id="x1-46027r1"></a></span>u=$(nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:boot-path | sed &#x0027;s/.*GPT,\([^,]*\),.*/\1/&#x0027;); \ <br /> 
<span class="label"><a 
 id="x1-46028r2"></a></span>  if [ &#x0022;$u&#x0022; != &#x0022;&#x0022; ]; then sudo diskutil mount $u ; fi</div>
     
     <!--l. 4082--><p class="noindent" >To obtain the current OpenCore version, use the following command in macOS: </p><!--l. 4083-->
     <div class="lstlisting" id="listing-12"><span class="label"><a 
 id="x1-46029r1"></a></span>nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:opencore-version</div>
     
     <!--l. 4086--><p class="noindent" >If the OpenCore version is not exposed the variable will contain UNK-000-0000-00-00 sequence.
     </p><!--l. 4089--><p class="noindent" >To obtain OEM information, use the following commands in macOS: </p><!--l. 4090-->
     <div class="lstlisting" id="listing-13"><span class="label"><a 
 id="x1-46030r1"></a></span>nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:oem-product # SMBIOS Type1 ProductName <br /> 
<span class="label"><a 
 id="x1-46031r2"></a></span>nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:oem-vendor  # SMBIOS Type2 Manufacturer <br /> 
<span class="label"><a 
 id="x1-46032r3"></a></span>nvram 4D1FDA02-38C7-4A6A-9CC6-4BCCA8B30102:oem-board   # SMBIOS Type2 ProductName</div>
     
     </li>
<li 
  class="enumerate" id="x1-46034x10">
     <!--l. 4097--><p class="noindent" >HaltLevel<br 
class="newline" />Type: plist integer, 64 bit<br 
class="newline" />Failsafe: 0x80000000 (DEBUG_ERROR)<br 
class="newline" />Description: EDK II debug level bitmask (sum) causing CPU to halt (stop execution) after obtaining a message of
     HaltLevel. Possible values match DisplayLevel values.
                                                                                                  
                                                                                                  
     
     
     
     
     
      
     
     
     
      
     
     
     
      
     
     
      
     
     
                                                                                                  
                                                                                                  
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     
      
     
         
      
     
     
      
     
     
      
     
     
      
     
     
      
     
     </body>
</html>